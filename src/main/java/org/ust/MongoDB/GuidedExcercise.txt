1. Create a New Database



use learningDB
Description
The use  in MongoDB is used to switch to a specific database.
If the specified database (learningDB) does not already exist, MongoDB will create it the first time you insert data into it. This  is essential for defining the context of the operations you will perform, ensuring all future s execute within the correct database.

Expected Output
switched to db learningDB

2. Insert a Single Document



db.students.insertOne({ name: "Alice", age: 20, major: "Computer Science" })
Description
The insertOne  adds a single document to a collection (here, students). MongoDB will automatically create the students collection if it doesn't exist yet. insertOne is typically used when you want to add a unique entry without batch insertion. Each document represents one entry, structured as a JSON object. The { acknowledged: true, insertedId: ObjectId("...") } output confirms that the insertion was successful, with insertedId showing the unique ID generated by MongoDB for this document.

Expected Output


{ acknowledged: true, insertedId: ObjectId("...") }

3. Insert Multiple Documents



db.students.insertMany([
  { name: "Bob", age: 22, major: "Mathematics" },
  { name: "Carol", age: 23, major: "Physics" }
])
Description
insertMany allows for the insertion of multiple documents at once.
This  is useful for bulk data uploads, minimizing the need for repeated insert s. Each document within the array represents a unique student record in the students collection. If successful, the output shows the insertedIds for each document, verifying that MongoDB has generated unique _id values.

Expected Output


{ acknowledged: true, insertedIds: { '0': ObjectId("..."), '1': ObjectId("...") } }
4. Find All Documents in a Collection



db.students.find()
Description
The find  retrieves all documents in the specified collection (students).
Without any filtering criteria, find() returns every document in the collection, displaying the full details of each record. This  is essential for inspecting the current data and verifying the records inserted earlier.

Expected Output


[
  { "_id": ObjectId("..."), "name": "Alice", "age": 20, "major": "Computer Science" },
  { "_id": ObjectId("..."), "name": "Bob", "age": 22, "major": "Mathematics" },
  { "_id": ObjectId("..."), "name": "Carol", "age": 23, "major": "Physics" }
]
5. Find Documents with a Filter



db.students.find({ age: { $gt: 21 } })
Description
In this , find is used with a filter to retrieve only documents that match specific conditions. Here, { age: { $gt: 21 } } finds students older than 21. The $gt operator represents "greater than," helping you selectively search for data based on particular fields.

Expected Output


[
  { "_id": ObjectId("..."), "name": "Bob", "age": 22, "major": "Mathematics" },
  { "_id": ObjectId("..."), "name": "Carol", "age": 23, "major": "Physics" }
]
6. Find a Single Document



db.students.findOne({ name: "Alice" })
Description
findOne returns the first document that matches the specified criteria, in this case, { name: "Alice" }. If multiple documents match, only the first one found will be returned. This  is useful when you know that a particular filter will match only one record or if you only need one document that meets the criteria.

Expected Output


{ "_id": ObjectId("..."), "name": "Alice", "age": 20, "major": "Computer Science" }
7. Count Documents



db.students.countDocuments({ major: "Physics" })
Description
The countDocuments  counts the number of documents that match a given filter—in this case, students majoring in "Physics." This is useful for summarizing data, such as finding how many records meet certain conditions.

Expected Output

1
8. Update a Single Document



db.students.updateOne({ name: "Alice" }, { $set: { age: 21 } })
Description
updateOne modifies the first document that matches the filter, { name: "Alice" }, by setting a new age value of 21. The $set operator updates specific fields, leaving other fields unchanged. This is useful for modifying individual properties without altering the entire document.

Expected Output
yaml

{ acknowledged: true, matchedCount: 1, modifiedCount: 1 }
9. Update Multiple Documents



db.students.updateMany({ age: { $gt: 21 } }, { $set: { status: "Graduate" } })
Description
updateMany updates all documents that match the filter. Here, all students over the age of 21 receive a new field, status, set to "Graduate". The $set operator ensures only the status field is added or updated, leaving other fields intact.

Expected Output
yaml

{ acknowledged: true, matchedCount: 2, modifiedCount: 2 }
10. Delete a Single Document



db.students.deleteOne({ name: "Alice" })
Description
deleteOne removes the first document that matches the filter { name: "Alice" }. This  is typically used when you know a unique identifier or specific condition that only one document should match, preventing accidental mass deletion.

Expected Output
yaml

{ acknowledged: true, deletedCount: 1 }
11. Delete Multiple Documents



db.students.deleteMany({ age: { $gt: 22 } })
Description
deleteMany deletes all documents that match the filter condition. In this example, it removes any document where age is greater than 22. This  is useful for removing groups of documents based on certain criteria, such as outdated records or invalid entries.

Expected Output
yaml

{ acknowledged: true, deletedCount: 1 }
12. Drop a Collection



db.students.drop()
Description
drop is a method used to delete an entire collection from the database, including all documents within it. This  is useful when you need to remove all data associated with a collection, effectively resetting it.

Expected Output
arduino

true
13. Create a Collection with a Schema Validator



db.createCollection("courses", {
  validator: { $jsonSchema: {
     bsonType: "object",
     required: [ "name", "credits" ],
     properties: {
        name: { bsonType: "string", description: "must be a string and is required" },
        credits: { bsonType: "int", minimum: 1, maximum: 5, description: "must be an integer between 1 and 5 and is required" }
     }
  }}
})
Description
The createCollection  creates a collection with specific rules. Here, courses has a schema requiring a name (string) and credits (integer from 1 to 5). Schema validation enforces data consistency, ensuring new documents follow the defined structure and constraints.

Expected Output


{ "ok" : 1 }


14. Insert a Document with Schema Validation



db.courses.insertOne({ name: "Algorithms", credits: 3 })
Description
This  inserts a document into the courses collection.
Since the collection has a schema validator (defined earlier in Step 13), the document must meet specific criteria. Here, the name field is a string, and credits is an integer within the allowed range (1-5). Schema validation will block insertion if the document doesn’t follow these rules.

Expected Output


{ acknowledged: true, insertedId: ObjectId("...") }
15. Attempt to Insert a Document that Fails Schema Validation



db.courses.insertOne({ name: "Calculus", credits: 6 })
Description
Attempting to insert a document where credits is 6 (outside the allowed range of 1-5) triggers schema validation. MongoDB rejects this document to enforce the constraints set by the schema.

Expected Output


Error: Document failed validation
16. Create an Index on a Field



db.courses.createIndex({ name: 1 })
Description
The createIndex  creates an index on the name field of the courses collection. Indexing improves the performance of queries, making it faster to search, filter, and sort based on the indexed field. Here, 1 specifies an ascending order index, though this choice won’t impact equality queries.

Expected Output


{ "createdCollectionAutomatically": false, "numIndexesBefore": 1, "numIndexesAfter": 2, "ok": 1 }
17. List All Indexes



db.courses.getIndexes()
Description
getIndexes lists all indexes present on the collection. This  is useful for verifying which indexes exist and understanding the structure MongoDB uses to optimize query performance.

Expected Output


[
  { "v": 2, "key": { "_id": 1 }, "name": "_id_" },
  { "v": 2, "key": { "name": 1 }, "name": "name_1" }
]
18. Drop an Index



db.courses.dropIndex("name_1")
Description
This  removes an existing index from the courses collection. Dropping unnecessary indexes helps optimize storage and performance if certain queries or fields are no longer needed.

Expected Output


{ "nIndexesWas": 2, "ok": 1 }
19. Aggregation Example



db.students.aggregate([
  { $group: { _id: "$major", avgAge: { $avg: "$age" } } }
])
Description
The aggregate function performs advanced data operations. Here, it groups documents in the students collection by the major field and calculates the average age of students for each major. Aggregation pipelines allow for data transformation, calculations, and summarization, which are useful for generating reports.

Expected Output


[
  { "_id": "Mathematics", "avgAge": 22 },
  { "_id": "Physics", "avgAge": 23 }
]
20. Add an Array Field to a Document



db.students.updateOne(
  { name: "Bob" },
  { $set: { skills: ["Mathematics", "Statistics"] } }
)
Description
This updateOne  uses $set to add an array field called skills to Bob’s document. Arrays allow you to store lists of items directly within a document, which is useful for maintaining collections of related data within a single entry.

Expected Output
yaml

{ acknowledged: true, matchedCount: 1, modifiedCount: 1 }
21. Use $push Operator to Append to an Array



db.students.updateOne({ name: "Bob" }, { $push: { skills: "Programming" } })
Description
$push adds a value to an existing array. Here, "Programming" is appended to the skills array in Bob’s document. $push ensures each element is added individually without overwriting the array. It’s particularly useful for dynamically growing an array with new values.

Expected Output
yaml

{ acknowledged: true, matchedCount: 1, modifiedCount: 1 }
22. Use $in Operator to Filter Results



db.students.find({ major: { $in: ["Mathematics", "Physics"] } })
Description
The $in operator matches any documents where the major field matches any of the values in the specified array (["Mathematics", "Physics"]). This  is handy for retrieving documents that fit multiple possible criteria, such as finding students in specific majors.

Expected Output


[
  { "_id": ObjectId("..."), "name": "Bob", "age": 22, "major": "Mathematics" },
  { "_id": ObjectId("..."), "name": "Carol", "age": 23, "major": "Physics" }
]
23. Rename a Field in All Documents



db.students.updateMany({}, { $rename: { "major": "field_of_study" } })
Description
$rename changes the name of a field. Here, it renames major to field_of_study in all documents. This is useful for applying naming conventions consistently across all entries without manually updating each document.

Expected Output
yaml

{ acknowledged: true, matchedCount: 2, modifiedCount: 2 }
24. Limit the Number of Results



db.students.find().limit(2)
Description
limit specifies the maximum number of documents returned by a query. This  can be used for pagination or controlling the output in queries that yield large datasets.

Expected Output


[
  { "_id": ObjectId("..."), "name": "Alice", "age": 20, "field_of_study": "Computer Science" },
  { "_id": ObjectId("..."), "name": "Bob", "age": 22, "field_of_study": "Mathematics" }
]
25. Sort Results by a Field



db.students.find().sort({ age: -1 })
Description
The sort function orders documents based on the specified field. Here, { age: -1 } sorts documents in descending order by age. A value of 1 would sort in ascending order. Sorting is particularly useful for ordering results based on priority fields.

Expected Output


[
  { "_id": ObjectId("..."), "name": "Carol", "age": 23, "field_of_study": "Physics" },
  { "_id": ObjectId("..."), "name": "Bob", "age": 22, "field_of_study": "Mathematics" },
  { "_id": ObjectId("..."), "name": "Alice", "age": 20, "field_of_study": "Computer Science" }
]



Additional Notes
For each , remember that:

MongoDB automatically generates _id fields for inserted documents.
s like insertOne, updateOne, and deleteOne operate on single documents, while insertMany, updateMany, and deleteMany apply to multiple documents.
Aggregation and indexing are advanced MongoDB features that improve data handling and query performance.